event-category.module import { Module } from "@nestjs/common"; import { PrismaService } from "../prisma.service.js"; import { EventCategoryController } from "./event-category.controller.js"; import { EventCategoryService } from "./event-category.service.js"; import { ConfigModule } from "../config/config.module.js"; @Module({ imports: [ConfigModule], controllers: [EventCategoryController], providers: [EventCategoryService, PrismaService], exports: [EventCategoryService], }) export class EventCategoryModule { } |||| event-category.controller import { Controller, Get, Query, Post, Body, HttpCode, HttpStatus, Param, Patch, Delete, UseGuards, } from "@nestjs/common"; import { EventCategoryService } from "./event-category.service.js"; import { CreateEventCategoryDto, createEventCategorySchema, UpdateEventCategoryDto, updateEventCategorySchema, GetEventCategoryByIdDto, getEventCategoryByIdSchema, ListEventCategoriesQueryDto, listEventCategoriesQuerySchema, } from "./event-category.validation.js"; import { ZodValidationPipe } from "nestjs-zod"; import { Role } from "../common/decorators/roles.decorator.js"; import { JwtAuthGuard } from "../common/guards/jwt-auth.guard.js"; import { RolesGuard } from "../common/guards/roles.guard.js"; import { User } from "../common/decorators/user.decorator.js"; import { UserDetails } from "../common/interfaces/user-details.interface.js"; @UseGuards(JwtAuthGuard, RolesGuard) @Controller("event-category") export class EventCategoryController { constructor(private readonly eventCategoryService: EventCategoryService) { } @Post() @Role("ADMIN") @HttpCode(HttpStatus.CREATED) async createEventCategory( @Body(new ZodValidationPipe(createEventCategorySchema)) dto: CreateEventCategoryDto, @User() user: UserDetails, ) { return this.eventCategoryService.createEventCategory(dto, user.user_id); } @Get() @Role("MEMBER", "ADMIN") async listEventCategories( @Query(new ZodValidationPipe(listEventCategoriesQuerySchema)) query: ListEventCategoriesQueryDto, ) { return this.eventCategoryService.listEventCategories( query.page, query.pageSize, query.search, ); } @Patch(":id") @Role("ADMIN") async updateEventCategory( @Param(new ZodValidationPipe(getEventCategoryByIdSchema)) params: GetEventCategoryByIdDto, @Body(new ZodValidationPipe(updateEventCategorySchema)) dto: UpdateEventCategoryDto, @User() user: UserDetails, ) { return this.eventCategoryService.updateEventCategory(params.id, dto, user.user_id); } @Delete(":id") @Role("ADMIN") async deleteEventCategory( @Param(new ZodValidationPipe(getEventCategoryByIdSchema)) params: GetEventCategoryByIdDto, @User() user: UserDetails, ) { return this.eventCategoryService.deleteEventCategory(params.id, user.user_id); } } |||| event-category.service import { Injectable, NotFoundException, BadRequestException } from "@nestjs/common"; import { PrismaService } from "../prisma.service.js"; import { PinoLogger } from "nestjs-pino"; import { Prisma } from "@prisma/client"; @Injectable() export class EventCategoryService { constructor( private prisma: PrismaService, private readonly logger: PinoLogger, ) { this.logger.setContext(EventCategoryService.name); } /** * Create a new event category */ async createEventCategory(dto: { name: string; description: string }, userId?: string) { // Check if event category with same name already exists and is not deleted const existing = await this.prisma.eventCategory.findFirst({ where: { name: { equals: dto.name, mode: "insensitive", }, isDeleted: false, }, }); if (existing) { throw new BadRequestException("Event category with this name already exists"); } const eventCategory = await this.prisma.eventCategory.create({ data: { name: dto.name, description: dto.description, createdBy: userId, }, }); return { message: "Event category created successfully", data: eventCategory, }; } /** * Update an event category */ async updateEventCategory(id: string, dto: { name?: string; description?: string }, userId?: string) { const existing = await this.prisma.eventCategory.findFirst({ where: { id, isDeleted: false }, }); if (!existing) { throw new NotFoundException("Event category not found"); } // Check if name is being updated and if it conflicts with another category if (dto.name && dto.name !== existing.name) { const nameConflict = await this.prisma.eventCategory.findFirst({ where: { name: { equals: dto.name, mode: "insensitive", }, id: { not: id }, isDeleted: false, }, }); if (nameConflict) { throw new BadRequestException("Event category with this name already exists"); } } const eventCategory = await this.prisma.eventCategory.update({ where: { id }, data: { ...dto, updatedBy: userId, }, }); return { message: "Event category updated successfully", data: eventCategory, }; } /** * List event categories with pagination, search, and filtering */ async listEventCategories( page: number = 1, pageSize: number = 100, search?: string, ) { const where: Prisma.EventCategoryWhereInput = { isDeleted: false, }; // Search filter - searches in both name and description if (search) { where.OR = [ { name: { contains: search, mode: "insensitive", }, }, { description: { contains: search, mode: "insensitive", }, }, ]; } const [items, total] = await Promise.all([ this.prisma.eventCategory.findMany({ where, orderBy: { name: "asc" }, skip: (page - 1) * pageSize, take: pageSize, }), this.prisma.eventCategory.count({ where }), ]); return { message: "Event categories retrieved successfully", data: { items, pagination: { page, pageSize, total, totalPages: Math.ceil(total / pageSize), }, }, }; } /** * Soft delete an event category */ async deleteEventCategory(id: string, userId?: string) { const existing = await this.prisma.eventCategory.findFirst({ where: { id, isDeleted: false }, }); if (!existing) { throw new NotFoundException("Event category not found"); } const eventCategory = await this.prisma.eventCategory.update({ where: { id }, data: { isDeleted: true, deletedAt: new Date(), deletedBy: userId, }, }); return { message: "Event category deleted successfully", data: { id: eventCategory.id, }, }; } } ||||| event-category.validation import { z } from "zod"; import { createZodDto } from "nestjs-zod"; export const createEventCategorySchema = z.object({ name: z .string({ error: "Name must be a string" }) .trim() .min(1, { message: "Name is required" }) .max(100, { message: "Name must be at most 100 characters" }), description: z .string({ error: "Description must be a string" }) .trim() .min(1, { message: "Description is required" }) .max(500, { message: "Description must be at most 500 characters" }), }); export class CreateEventCategoryDto extends createZodDto(createEventCategorySchema) { } export const updateEventCategorySchema = z.object({ name: z .string({ error: "Name must be a string" }) .trim() .min(1, { message: "Name is required" }) .max(100, { message: "Name must be at most 100 characters" }) .optional(), description: z .string({ error: "Description must be a string" }) .trim() .min(1, { message: "Description is required" }) .max(500, { message: "Description must be at most 500 characters" }) .optional(), }); export class UpdateEventCategoryDto extends createZodDto(updateEventCategorySchema) { } export const getEventCategoryByIdSchema = z.object({ id: z.string().uuid({ message: "Invalid event category ID" }), }); export class GetEventCategoryByIdDto extends createZodDto(getEventCategoryByIdSchema) { } export const listEventCategoriesQuerySchema = z.object({ page: z .string() .optional() .default("1") .transform((val) => parseInt(val, 10)) .refine((val) => val > 0, { message: "Page must be greater than 0" }), pageSize: z .string() .optional() .default("100") .transform((val) => parseInt(val, 10)) .refine((val) => val > 0 && val <= 200, { message: "Page size must be between 1 and 200", }), search: z .string({ error: "Search must be a string" }) .trim() .min(1, { message: "Search query must be at least 1 character" }) .optional(), }); export class ListEventCategoriesQueryDto extends createZodDto(listEventCategoriesQuerySchema) { } i sent all 4 files and this was my task to perform model EventCategory { id String @id @default(uuid()) createdAt DateTime @default(now()) updatedAt DateTime @updatedAt name String description String events Event[] isDeleted Boolean @default(false) createdBy String? createdByUser User? @relation(fields: [createdBy], references: [id], name: "eventCategoryCreatedBy") updatedBy String? updatedByUser User? @relation(fields: [updatedBy], references: [id], name: "eventCategoryUpdatedBy") deletedBy String? deletedByUser User? @relation(fields: [deletedBy], references: [id], name: "eventCategoryDeletedBy") deletedAt DateTime? @@map("event_categories") }